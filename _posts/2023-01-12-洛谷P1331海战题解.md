---
layout: post
title: "洛谷P1331海战题解"
date: 2023-01-12
categories: algorithm
tags: [DFS,深度优先搜索,算法,题解]
---

>本文是洛谷P1331**海战**的题解。

先上题目：

# 海战

## 题目背景

在峰会期间，武装部队得处于高度戒备。警察将监视每一条大街，军队将保卫建筑物，领空将布满了 F-2003 飞机。

此外，巡洋船只和舰队将被派去保护海岸线。不幸的是，因为种种原因，国防海军部仅有很少的几位军官能指挥大型海战。因此，他们培养了一些新海军指挥官。军官们选择了“海战”游戏来帮助他们学习。

## 题目描述

在一个方形的盘上，放置了固定数量和形状的船只，每只船却不能碰到其它的船。在本题中，我们认为船是方形的，所有的船只都是由图形组成的方形。

求出该棋盘上放置的船只的总数。

## 输入格式

第一行为两个整数 $R$ 和 $C$，用空格隔开，分别表示游戏棋盘的行数和列数。

接下来 $R$ 行，每行 $C$ 个字符，为 `#` 或 `.`。`#` 表示船只的一部分，`.` 表示水。

## 输出格式

一行一个字符串，如果船的位置放得正确（即棋盘上只存在相互之间不能接触的方形，如果两个 `#` 号上下相邻或左右相邻却分属两艘不同的船只，则称这两艘船相互接触了）。就输出 `There are S ships.`，$S$ 表示船只的数量。否则输出 `Bad placement.`。

## 样例 #1

### 样例输入 #1

```
6 8
.....#.#
##.....#
##.....#
.......#
#......#
#..#...#
```

### 样例输出 #1

```
There are 5 ships.
```

## 提示

对于 $100\%$ 的数据，$1 \le R,C \le 1000$。

# 思路

这道题和[洛谷P1596 [USACO10OCT]Lake Counting S](https://www.luogu.com.cn/problem/P1596)很像，可以去做做看。

## 特判

本题唯一需要添加的是一个特判。题目说`如果两个#号上下相邻或左右相邻却分属两艘不同的船只，则称这两艘船相互接触了`，这意味着不同的船只组合有以下4种情况：

1.

```
##
#
```

2.

```
#
##
```

3.

```
##
 #
```

4.

```
 #
##
```

那么，我们怎么来判断以上四种**不合法**的船只呢？我们不难发现，发生这种情况的船只在4个格子中占3个`#`，这就很好解决了：设置一个`bool`函数`d`，分别判断**四个位置**是否为`#`，设一个变量`n`，当`位置=='#'`时`n++`，如果`n=3`那么~~这条~~这部分船不合法，`return 0`，否则就是合法，`return 1`，这就是特判函数。

其他部分就跟[DFS走迷宫](https://yurlak.github.io/algorithm/2023/01/02/DFS%E8%B5%B0%E8%BF%B7%E5%AE%AB.html)一样啦。

# 代码实现

下面上代码：

```
#include<bits/stdc++.h>
using namespace std;
int r,c,tx=0,ty=0,ans=0;
char a[1010][1010];
int fx[4]={0,-1,0,1};
int fy[4]={1,0,-1,0};
void dfs(int x,int y){
	a[x][y]='*';
	for(int i=0;i<4;i++){
		tx=x+fx[i];
		ty=y+fy[i];
		if(tx>0&&tx<=r&&ty>0&&ty<=c&&a[tx][ty]=='#'){
			dfs(tx,ty);
		}
	}
}
bool d(int i,int j){//特判函数
	int n=0;
	if(a[i][j]=='#') n++;
	if(a[i+1][j]=='#') n++;
	if(a[i][j+1]=='#') n++;
	if(a[i+1][j+1]=='#') n++;
  //枚举四个位置
	if(n==3) return 0;
	else return 1; 
  //判断是否合法
}
int main(){
	cin>>r>>c;
	for(int i=1;i<=r;i++){
		for(int j=1;j<=c;j++){
			cin>>a[i][j];
		}
	}//输入矩阵
	for(int i=1;i<=r;i++){
		for(int j=1;j<=c;j++){
			if(d(i,j)==0){
				cout<<"Bad placement.";
				return 0;
			}
		}
	}//判断 
	for(int i=1;i<=r;i++){
		for(int j=1;j<=c;j++){
			if(a[i][j]=='#'){
				ans++;
				dfs(i,j);
			} 
		}
	}
	cout<<"There are "<<ans<<" ships.";
}
```
